" Just a few settings
" Check settings with ":verbose set <setting>?"
" vim: fdm=marker fdl=0 tw=200

" utf-8 settings
scriptencoding utf-8
set encoding=utf-8
set termencoding=utf-8
let mapleader = "\<Space>"

" Plugins " {{{1
if empty(glob('~/.vim/autoload/plug.vim'))
  silent !curl -fLo ~/.vim/autoload/plug.vim --create-dirs
    \ https://raw.githubusercontent.com/junegunn/vim-plug/master/plug.vim
  autocmd VimEnter * PlugInstall
endif
nnoremap ,pc :PlugClean<CR>
nnoremap ,pi :PlugInstall<CR>
nnoremap ,ps :PlugStatus<CR>
nnoremap ,pu :PlugUpdate<CR>
let g:plug_shallow = 0

silent! if  plug#begin('~/.vim/plugged')
Plug 'junegunn/fzf', { 'dir': '~/.fzf', 'do': 'yes \| ./install' }
" fzf config {{{2
  set rtp+=~/.fzf
" }}}
Plug 'junegunn/fzf.vim'
" fzf.vim config {{{2
  let g:fzf_buffers_jump               = 1
  nnoremap          <Leader>p            :Files<CR>
  nnoremap          <Leader>a            :Ag<Space>
  nnoremap          <Leader>b            :Buffers<CR>
  nnoremap          <Leader>c            :Colors<CR>
  nnoremap          <Leader>m            :History<CR>
  nnoremap          <Leader>t            :BTags<CR>
  imap              <C-x><C-f>           <plug>(fzf-complete-file-ag)
  imap              <C-x><C-l>           <plug>(fzf-complete-line)
  autocmd VimEnter * command! Colors call fzf#vim#colors({'left': '14%', 'options': ''})
" }}}
Plug 'junegunn/vim-peekaboo'
Plug 'junegunn/limelight.vim'
" limelight.vim config {{{2
  nnoremap <silent> ,tl                  :Limelight!!<CR>
  let g:limelight_conceal_ctermfg      = 238
  let g:limelight_conceal_guifg        = '#444444'
  let g:limelight_default_coefficient  = 2.4
" }}}
Plug 'tpope/vim-abolish'
Plug 'tpope/vim-commentary'
Plug 'tpope/vim-eunuch'
Plug 'tpope/vim-repeat'
Plug 'tpope/vim-rsi'
Plug 'tpope/vim-surround'
Plug 'tpope/vim-vinegar'
Plug 'tpope/vim-fugitive' | Plug 'gregsexton/gitv' | Plug 'junkblocker/git-time-lapse'
" git related config {{{2
  let g:Gitv_OpenHorizontal            = 'auto'
  nnoremap <silent> <Leader>gV           :Gitv --all<CR>
  nnoremap <silent> <Leader>gv           :Gitv! --all<CR>
  vnoremap <silent> <Leader>gv           :Gitv! --all<CR>
  nnoremap          <Leader>gt           :GitTimeLapse<CR>
  nnoremap          <Leader>tig          :!tig<CR>:redraw!<CR>
" }}}
Plug 'justinmk/vim-sneak'
" vim-sneak config {{{2
  let g:sneak#prompt = '[sneak]'
  let g:sneak#streak = 1
" }}}
Plug 'mhinz/vim-signify'
" vim-signify config {{{2
  let g:signify_sign_add               = '+'
  let g:signify_sign_change            = '!'
  let g:signify_sign_delete            = '-'
  let g:signify_sign_delete_first_line = '‾'
  let g:signify_line_highlight         = 1
  let g:signify_update_on_focusgained  = 1
  nnoremap          ,tsg                 :SignifyToggle<CR>
" }}}
Plug 'mhinz/vim-sayonara', {'on': 'Sayonara' }
Plug 'romainl/vim-qf'
" vim-qf config {{{2
  let g:qf_mapping_ack_style           = 1
  nmap              <C-q>                <Plug>QfSwitch
  nmap              <C-c>                <Plug>QfCtoggle
  nmap              <C-l>                <Plug>QfLtoggle
  nmap              <Home>               <Plug>QfCprevious
  nmap              <End>                <Plug>QfCnext
  nmap              <C-Home>             <Plug>QfLprevious
  nmap              <C-End>              <Plug>QfLnext
" }}}
Plug 'romainl/vim-qlist'
Plug 'ajh17/VimCompletesMe'
Plug 'wellle/tmux-complete.vim'
Plug 'wellle/targets.vim'
Plug 'mbbill/undotree', { 'on': 'UndotreeToggle' }
" undotree config {{{2
  let g:undotree_WindowLayout          = 2
  nnoremap          ,tu                  :UndotreeToggle<CR>
" }}}
Plug 'qpkorr/vim-renamer'
Plug 'will133/vim-dirdiff'
" vim-dirdiff config {{{2
  let g:DirDiffExcludes                = ".git,.svn,CVS,*.class,*.exe,.*.swp,*.pyc,*.so,*.png,*.jp*g,*.svg,*.tiff}"
" }}}
Plug 'VOoM'
" VOoM config {{{2
  let g:voom_tree_width                = 40
  let g:voom_ft_modes                  = {'adoc': 'asciidoc', 'asciidoc': 'asciidoc', 'markdown': 'markdown', 'md': 'markdown', 'rst': 'rest', 'tex': 'latex'}
  nnoremap          ,tv                  :VoomToggle<CR>
" }}}
Plug 'rkitover/vimpager'
Plug 'powerman/vim-plugin-viewdoc'
" vim-plugin-viewdoc config {{{2
  let g:viewdoc_open                   = 'topleft new'
  let g:viewdoc_openempty              = 0
  let g:viewdoc_dontswitch             = 0
  nnoremap          <Leader>h            :ViewDocHelp<Space>
" }}}
Plug 'godlygeek/tabular' | Plug 'dhruvasagar/vim-table-mode'
" tabular config {{{2
  nnoremap          <Leader><Tab>        :Tabular 
  vnoremap          <Leader><Tab>        :Tabular 
" }}}
" vim-table-mode config {{{2
  let g:table_mode_corner              = '+'
  let g:table_mode_fillchar            = '-'
  let g:table_mode_align_char          = ':'
" }}}
Plug 'jamessan/vim-gnupg'
Plug 'mattn/webapi-vim' | Plug 'mattn/gist-vim', { 'on': 'Gist' }
" webapi-vim config {{{2
  let g:gist_post_private              = 1
  let g:gist_clip_command              = 'xclip -selection clipboard'
" }}}
Plug 'SyntaxAttr.vim'
Plug 'visSum.vim'
Plug 'chrisbra/unicode.vim'
" unicode.vim config {{{2
  nnoremap          <Leader>us           :UnicodeSearch<Space>
  nnoremap          <Leader>ut           :UnicodeTable<CR>
  nnoremap          ga                   :UnicodeName<CR>
" }}}
Plug 'chrisbra/Colorizer', { 'on': 'ColorToggle' }
" Colorizer config {{{2
  nnoremap          ,tc                  :ColorToggle<CR>
" }}}
Plug '$HOME/.vim/plugged/my-base16-vim'
" base16-vim config {{{2
  let base16colorspace                 = 256
  let g:base16_shell_path              = "$HOME/.config/base16-shell"
" }}}
Plug 'wimstefan/ligero-theme'
Plug 'wimstefan/Lightning'
Plug 'romainl/Apprentice'
Plug 'reedes/vim-colors-pencil'
" vim-colors-pencil config {{{2
  let g:pencil_terminal_italics        = 1
" }}}
Plug 'robertmeta/nofrils'
Plug 'jonathanfilip/vim-lucius'

call plug#end()
endif
" " }}}

" General Settings " {{{1
filetype indent plugin on
syntax   on
runtime  macros/matchit.vim
runtime  ftplugin/man.vim

set textwidth=80                       " define an acceptable standard textwidth
set backspace=2                        " allow backspacing over everything in insert mode
set shiftwidth=2                       " number of spaces used for indention
let &softtabstop = &shiftwidth         " number of spaces that a <Tab> counts for
set shiftround                         " round indent to multiple of 'shiftwidth'
set expandtab                          " use spaces to insert a <Tab>
set smarttab                           " smart tab handling for indenting
set autoindent                         " set autoindenting on

set hidden                             " allow buffers to go in background without saving etc.
set autowrite                          " save automatically before critical operations
set autoread                           " automatically reads & loads changes
set nobackup                           " keep a backup file

"set viminfo='50,\"100,:100,%          " read/write a viminfo file with buffer list
set viminfo='50,\"100,:100             " read/write a viminfo file without buffer list
if has ('nvim')
  set viminfo+=n$HOME/.cache/nvim/viminfo " specify where to write the viminfo
else
  set viminfo+=n$HOME/.cache/vim/viminfo " specify where to write the viminfo
endif
set history=100                        " keep 100 lines of command line history

set number                             " show line numbers
set cursorcolumn                       " highlights the screen column of the cursor
set cursorline                         " highlights the screen line of the cursor
let &cc='+'.join(range(1,255),',+')    " highlights textwidth boundaries
if exists('vimpager')
  set colorcolumn=0
  set nolist
endif
" virtually wrap lines to fit on the screen
if exists('+linebreak')
  set linebreak showbreak=\ ›››\ 
endif
if has('patch594')
  set breakindent
endif

set ignorecase                         " ignore case when using a search pattern
set smartcase                          " override 'ignorecase' when pattern has upper case characters
set incsearch                          " show matches while typing the query
set hlsearch                           " highlight search results

set completeopt=preview,menuone

set list                               " display unprintable characters
set listchars=tab:→\ ,trail:·,eol:«,extends:◀,precedes:▶

set path+=**                          " list of directories which will be searched with find et al
set isfname=@,48-57,/,.,-,_,+,,,#,$,%,~,=,(,),[,],{,}     " allowed characters in file and path names

set wildmenu                           " use a scrollable menu for filename completions
set wildchar=<tab>                     " the char used for 'expansion' on the command line
set wildmode=list:longest,full         " show list of completions and complete as much as possible, then iterate full completions
set wildignore+=*.swp,*.bak,*.pyc,*.cache,*.dll,*.pdb,*.tar.*
set wildignore+=*/.git/**/*,*/.hg/**/*,*/.svn/**/*

set modeline                           " allow the execution of modelines
set showmode                           " shows mode
set showcmd                            " show uncompleted command
set showmatch                          " show matching hyphens
set diffopt=vertical,iwhite,filler     " split vertical, ignore whitespace & use filler
set splitright                         " Set vertical splits to split to the right
set splitbelow                         " Set horizontal splits to split to the bottom
set previewheight=24                   " Set the height of the preview window

set gdefault                           " always use global substitutions
set digraph                            " enter characters that normally can't be entered by keyboard

" Use persistent undo
if has('persistent_undo')
  set undodir=$HOME/.cache/vim/undo
  set undolevels=5000
  set undofile
endif

" Clipboard settings
if has('unnamed')
  set clipboard+=unnamed               " yank+paste with the '*' register
endif

" Mouse settings
set mouse=a                            " enable mouse in console
set mousemodel=popup_setpos
if !has('nvim')
  set ttymouse=xterm2
endif

" Fold settings
set foldenable                         " turn on folding
set foldmethod=indent                  " fold on indentation (only use marker if explicitly defined)
set foldlevel=100                      " don't autofold anything (but I can still fold manually)

" Search settings
if executable('ag')
  " set grepprg=ag\ --nogroup\ --column\ --smart-case\ --nocolor\ --follow
  set grepprg=ag\ --vimgrep
  set grepformat=%f:%l:%c:%m
elseif executable('ack')
  set grepprg=ack\ --nogroup\ --column\ --smart-case\ --nocolor\ --follow\ $*
  set grepformat=%f:%l:%c:%m
endif

" Spell settings
set spelllang=nl,en,de,es
set spellfile=~/.vim/spell/myspell.utf-8.add
set spellsuggest=fast
if $USER=='root'
  set nospell
else
  set nospell
endif

" Print settings
set printoptions=paper:A4,header:0

" Netrw settings
let g:netrw_winsize        = 20
let g:netrw_liststyle      =  3
let g:netrw_preview        =  0
let g:netrw_alto           =  0
nnoremap <silent> <Leader>x :Lexplore<CR>

" " }}}

" Visual " {{{1
set background=dark
if has('nvim')
  if has(v:version >= 1.0.5)
    set termguicolors
  else
    let $NVIM_TUI_ENABLE_TRUE_COLOR=1
  endif
else
  let &t_8f="\e[38;2;%lu;%lu;%lum"
  let &t_8b="\e[48;2;%lu;%lu;%lum"
  set termguicolors
endif
if &term =~ "linux"
  color pencil
else
  if has('gui_running')
    if $USER=='root'
      color apprentice
    else
      source $HOME/.config/colorscheme
    endif
  else
    if $USER=='root'
      source $HOME/.config/colorscheme
    else
      source $HOME/.config/colorscheme
      if exists("g:colors_name") && g:colors_name == "lucius" && &background == "dark"
        LuciusBlack
      elseif exists("g:colors_name") && g:colors_name == "lucius" && &background == "light"
        LuciusWhiteLowContrast
      endif
    endif
  endif
endif

set guifont=PragmataPro\ 11
set guioptions-=T                      " disable toolbar

" Statusline " {{{2
set laststatus=2                       " always show the statusline above
set guioptions-=e                      " disables the GUI tab line in favor of the plain text version

function! s:user_highlights()
  exec 'hi CursorLine cterm=bold gui=bold'
  exec 'hi User1 cterm=reverse gui=reverse'
  exec 'hi Status1 ctermfg=1 ctermbg=' . synIDattr(hlID('StatusLine'), 'bg', 'cterm') . ' guifg=#ff0000 guibg=' . synIDattr(hlID('StatusLine'), 'bg', 'gui')
  exec 'hi Status2 ctermfg=2 ctermbg=' . synIDattr(hlID('StatusLine'), 'bg', 'cterm') . ' guifg=#a5ffe1 guibg=' . synIDattr(hlID('StatusLine'), 'bg', 'gui')
  exec 'hi Status3 ctermfg=3 ctermbg=' . synIDattr(hlID('StatusLine'), 'bg', 'cterm') . ' guifg=#ffff00 guibg=' . synIDattr(hlID('StatusLine'), 'bg', 'gui')
  exec 'hi Status4 ctermfg=4 ctermbg=' . synIDattr(hlID('StatusLine'), 'bg', 'cterm') . ' guifg=#97bbf7 guibg=' . synIDattr(hlID('StatusLine'), 'bg', 'gui')
endfunction
call s:user_highlights()

function! MyStatusline()
  let stl  = ''
  if $USER=='root'
    let stl .= '%#Status1# ■ '
  else
    let stl .= ' ■ '
  endif
  let stl .= '%1* %f %*'
  if $USER=='root'
    let stl .= '%#Status1# ■ %*'
  else
    let stl .= ' ■ %*'
  endif
  let stl .= '%#Status2#%{&modified ? " ✓ " : ""}%*'
  let stl .= '%#Status1#%{&ro ? " ✗ " : ""}%*'
  let stl .= '%{sneak#is_sneaking()?"[sneak]":""}'
  let stl .= '%= '
  if exists('b:git_dir') && winwidth(0) > 70
    let branch  = fugitive#head(8)
    let stl    .= (branch == 'master') ? '· master' : '· '. branch
    if exists('g:loaded_signify')
      let stl    .= s:sy_stats_wrapper().' · '
    endif
  endif
  let stl .= '%y'
  if winwidth(0) > 70
    if &fileformat != 'unix'
      let stl .= ' %{&encoding}[%{&fileformat}] '
    else
      let stl .= ' %{&encoding} '
    endif
  endif
    let stl .= '%1* %l:%-2c %*'
    let stl .= ' %p%% '
  return stl
endfunction
setlocal statusline=%!MyStatusline()
" " }}}2
" " }}}

" Formatting " {{{1
set comments=b:#,fb:-,fb:*,fb:o,:%,n:>|
set formatoptions=tcrqwnbj
set nrformats-=octal                   " do not recognize octal numbers for Ctrl-A and Ctrl-X
nnoremap Q gwap
vnoremap Q gw

" " }}}

" Key bindings & abbreviations " {{{1

" open/source $MYVIMRC
nnoremap <Leader>ev :edit    $MYVIMRC<CR>
nnoremap <Leader>sv :source  $MYVIMRC<CR>

" files
nnoremap <Leader>e  :e **/
nnoremap <Leader>f  :find *
nnoremap <Leader>s  :sfind *
nnoremap ,w         :grep<Space><C-r><C-w><CR>
nnoremap <Leader>g  :grep<Space>
nnoremap <Leader>l  :Locate<Space>
nnoremap <Leader>w  :w!<CR>
nnoremap <Leader>wa :wa!<CR>
nnoremap <Leader>q  :q!<CR>
nnoremap <Leader>qa :qa!<CR>

" buffers
nnoremap <Leader>bn :bnext<CR>
nnoremap <Leader>bp :bprev<CR>
nnoremap <Leader>bd :Sayonara<CR>

" signatures
nnoremap <Leader>sa 1G:s#\(Stefan Wimmer\) <.*>#\1 <stefan@tangoartisan.com>#<CR>
  \ G?--<CR>
  \ jVGd :r ~/.mutt/short-signature-artisan<CR>
  \ /^To:<CR>
nnoremap <Leader>sg 1G:s#\(Stefan Wimmer\) <.*>#\1 <wimstefan@gmail.com>#<CR>
  \ G?--<CR>
  \ jVGd :r ~/.mutt/short-signature-gmail<CR>
  \ /^To:<CR>
nnoremap <Leader>st G?--<CR>jVGd :r ~/.mutt/short-signature-tango<CR>
nnoremap <Leader>ss G?--<CR>jVGd :r ~/.mutt/short-signature<CR>
nnoremap <Leader>sl G?--<CR>jVGd :r ~/.mutt/signature<CR>

" some ideas stolen from tpope/vim-unimpaired
function! s:statusbump() abort
  let &l:readonly = &l:readonly
  return ''
endfunction

function! s:toggle(op) abort
  call s:statusbump()
  return eval('&'.a:op) ? 'no'.a:op : a:op
endfunction

function! s:option_map(letter, option, mode) abort
  exe 'nnoremap [o'.a:letter ':'.a:mode.' '.a:option.'<C-r>=<SID>statusbump()<CR><CR>'
  exe 'nnoremap ]o'.a:letter ':'.a:mode.' no'.a:option.'<C-r>=<SID>statusbump()<CR><CR>'
  exe 'nnoremap co'.a:letter ':'.a:mode.' <C-r>=<SID>toggle("'.a:option.'")<CR><CR>'
endfunction

nnoremap [ob :set background=light<CR>
nnoremap ]ob :set background=dark<CR>
nnoremap cob :set background=<C-r>=&background == 'dark' ? 'light' : 'dark'<CR><CR>
call s:option_map('c', 'cursorline', 'setlocal')
call s:option_map('u', 'cursorcolumn', 'setlocal')
nnoremap [od :diffthis<CR>
nnoremap ]od :diffoff<CR>
nnoremap cod :<C-r>=&diff ? 'diffoff' : 'diffthis'<CR><CR>
call s:option_map('h', 'hlsearch', 'set')
call s:option_map('i', 'ignorecase', 'set')
call s:option_map('l', 'list', 'setlocal')
call s:option_map('n', 'number', 'setlocal')
call s:option_map('r', 'relativenumber', 'setlocal')
call s:option_map('s', 'spell', 'setlocal')
nnoremap [ox :set cursorline cursorcolumn<CR>
nnoremap ]ox :set nocursorline nocursorcolumn<CR>
nnoremap cox :set <C-r>=&cursorline && &cursorcolumn ? 'nocursorline nocursorcolumn' : 'cursorline cursorcolumn'<CR><CR>
nmap [<Space> O<Esc>j
nmap ]<Space> o<Esc>k

" various
nnoremap <F12> :call SyntaxAttr()<CR>
set pastetoggle=<F3>

" Abbreviations
source $HOME/.vim/abbreviations.vim
" " }}}

" Auto commands " {{{1
" Automatically chmod +x Shell and Perl scripts
autocmd BufWritePost {*.sh,*.pl,*.py} silent !chmod +x %

" Differing commentstrings
autocmd FileType xdefaults setlocal commentstring=!\%s
autocmd FileType mail setlocal commentstring=>\%s

" Typical mutt thing ... replace > > with >>
autocmd BufRead /tmp/mutt* silent! %s/^\([>|]\s\?\)\+/\=substitute(submatch(0), '\s', '', 'g').' '
autocmd BufRead /tmp/mutt* set nonumber nohls nolist filetype=mail formatoptions=tcroqln21
autocmd BufRead /tmp/mutt* setlocal spell

" Syntax for tmux
autocmd BufNewFile,BufRead *tmux*conf* set filetype=tmux

" Syntax for conkyrc
autocmd BufNewFile,BufRead *conkyrc* set filetype=conkyrc

" Syntax for htp files
autocmd BufNewFile,BufRead {*.htp,*.htt} set filetype=xhtml

" Syntax for xmp files
autocmd BufNewFile,BufRead {*.xmp} set filetype=xml

" Syntax for fvwm files
autocmd BufNewFile,BufRead */.fvwm*/* set filetype=fvwm syntax=fvwm

" Syntax for Xorg log files
autocmd BufNewFile,BufRead *Xorg*log* set filetype=msmessages

" Change fileformat on playlist files (created by moc)
autocmd BufNewFile,BufRead *.m3u set encoding=utf-8 fileencoding=utf-8 ff=unix

" Encoding for cddb files
autocmd BufNewFile,BufRead *cddb* set encoding=utf-8 fileencoding=utf-8 ff=unix

" Disable numbers & spell inside manpages
autocmd FileType {man,help,perldoc,pydoc}  set nonumber nospell nolist nocursorcolumn

" Automatically open the quickfix window if it's populated
autocmd QuickFixCmdPost [^l]* nested cwindow
autocmd QuickFixCmdPost    l* nested lwindow

" When editing a file, always jump to the last known cursor position.
autocmd BufReadPost *
  \ if line("'\"") > 0 && line("'\"") <= line("$") |
  \       exe "normal g`\"" |
  \ endif

" Reload user defined highlights after changing colorschemes
autocmd ColorScheme * call s:user_highlights()

" Reload statusline after changing windows/buffer/tab
autocmd BufEnter * setlocal statusline=%!MyStatusline()

" Automatically reload vimrc when it's saved
autocmd  BufWritePost vimrc,.vimrc nested if expand('%') !~ 'fugitive' | source % | endif

" " }}}

" Functions " {{{1
function! s:sy_stats_wrapper()
  let symbols = ['+', '-', '~']
  let [added, modified, removed] = sy#repo#get_stats()
  let stats = [added, removed, modified]  " reorder
  let hunkline = ''

  for i in range(3)
    if stats[i] > 0
      let hunkline .= printf('%s%s ', symbols[i], stats[i])
    endif
  endfor

  if !empty(hunkline)
    let hunkline = printf(' %s', hunkline[:-2])
  endif

  return hunkline
endfunction

" " }}}

finish
Vim is ignoring *all* text after finish.
