" Just a few settings
" Check settings with ":verbose set <setting>?"
" vim: fdm=marker fdl=0 tw=200

let mapleader = "\<Space>"

" Plugins " {{{1
if empty(glob('~/.vim/autoload/plug.vim'))
  silent !curl -fLo ~/.vim/autoload/plug.vim --create-dirs
    \ https://raw.githubusercontent.com/junegunn/vim-plug/master/plug.vim
  autocmd! VimEnter * PlugInstall
endif
nnoremap ,pc :PlugClean<CR>
nnoremap ,pi :PlugInstall<CR>
nnoremap ,ps :PlugStatus<CR>
nnoremap ,pu :PlugUpdate<CR>
let g:plug_shallow = 0

silent! if  plug#begin('~/.vim/plugged')
Plug 'Yggdroot/LeaderF', { 'do': './install.sh' }
" LeaderF config {{{2
  let g:Lf_StlSeparator                = { 'left': "\u2563", 'right': "\u2560" }
  let g:Lf_WindowPosition              = 'right'
  let g:Lf_CacheDirectory              = expand('~/.cache/vim')
  let g:Lf_PreviewCode                 = 1
  let g:Lf_PreviewResult               = {
                                         \ 'File': 0,
                                         \ 'Buffer': 0,
                                         \ 'Mru': 0,
                                         \ 'Tag': 1,
                                         \ 'BufTag': 1,
                                         \ 'Rg': 0,
                                         \ 'Function': 1,
                                         \ 'Line': 0,
                                         \ 'Colorscheme': 1
                                         \}
  let g:Lf_WildIgnore                  = {
                                         \ 'dir': ['.svn','.git','.hg'],
                                         \ 'file': ['*.sw?','~$*','*.bak','*.exe','*.o','*.so','*.py[co]']
                                         \}
  nnoremap          <Leader>f            :Leaderf<Space>
  nnoremap          <Leader>p            :LeaderfFile<CR>
  nnoremap          <Leader>a            :LeaderfRgInteractive<CR>
  nnoremap          <Leader>b            :LeaderfBuffer<CR>
  nnoremap          <Leader>c            :LeaderfColorscheme<CR>
  nnoremap          <Leader>m            :LeaderfMru<CR>
  nnoremap          <Leader>h            :LeaderfHelp<CR>
  nmap              <Leader>r             <Plug>LeaderfRgPrompt
  nnoremap <silent> ,lbt                 :LeaderfBufTag<CR>
  nnoremap <silent> ,lf                  :LeaderfFunction<CR>
  nnoremap <silent> ,lfa                 :LeaderfFunctionAll<CR>
  nnoremap <silent> ,lhc                 :LeaderfHistoryCmd<CR>
  nnoremap <silent> ,lhs                 :LeaderfHistorySearch<CR>
  nmap              ,lsw                  <Plug>LeaderfRgBangCwordLiteralNoBoundary<CR>
" }}}
Plug 'junegunn/vim-peekaboo'
" vim-peekaboo config {{{2
  let g:peekaboo_ins_prefix            = '<C-x>'
" }}}
Plug 'junegunn/goyo.vim'
" goyo.vim config {{{2
  nnoremap <silent> ,tg                  :Goyo<CR>
  let g:goyo_width                     = 114
" }}}
Plug 'junegunn/limelight.vim'
" limelight.vim config {{{2
  nnoremap <silent> ,tl                  :Limelight!!<CR>
  let g:limelight_default_coefficient  = 0.7
" }}}
Plug 'junegunn/vim-easy-align'
" vim-easy-align config {{{2
  " Start interactive EasyAlign in visual mode (e.g. vipea)
  xmap              ea                    <Plug>(EasyAlign)
  " Start interactive EasyAlign for a motion/text object (e.g. eaip)
  nmap              ea                    <Plug>(EasyAlign)
" }}}
Plug 'tpope/vim-abolish'
Plug 'tpope/vim-eunuch'
Plug 'tpope/vim-flagship'
Plug 'tpope/vim-fugitive'
" git related config {{{2
  nnoremap          <Leader>gc           :<C-u>Gcommit -v %<CR>
  nnoremap          <Leader>gd           :<C-u>Gdiff<CR>
  nnoremap          <Leader>gl           :<C-u>0Glog<CR>
  nnoremap          <Leader>gp           :<C-u>Gpush<CR>
  nnoremap          <Leader>gs           :<C-u>Gstatus<CR>
" }}}
Plug 'tpope/vim-obsession'
" vim-obsession config {{{2
  nnoremap <silent> ,to                  :Obsession<CR>
" }}}
Plug 'tpope/vim-repeat'
Plug 'tpope/vim-vinegar'
Plug 'machakann/vim-sandwich'
Plug 'justinmk/vim-sneak'
" vim-sneak config {{{2
  let g:sneak#prompt                   = '[sneak] '
  let g:sneak#label                    = 1
  let g:sneak#s_next                   = 1
  nmap              f                    <Plug>Sneak_f
  nmap              F                    <Plug>Sneak_F
  xmap              f                    <Plug>Sneak_f
  xmap              F                    <Plug>Sneak_F
  omap              f                    <Plug>Sneak_f
  omap              F                    <Plug>Sneak_F
  nmap              t                    <Plug>Sneak_t
  nmap              T                    <Plug>Sneak_T
  xmap              t                    <Plug>Sneak_t
  xmap              T                    <Plug>Sneak_T
  omap              t                    <Plug>Sneak_t
  omap              T                    <Plug>Sneak_T
  nmap              s                    <Plug>Sneak_s
  nmap              S                    <Plug>Sneak_S
  xmap              s                    <Plug>Sneak_s
  xmap              S                    <Plug>Sneak_S
  omap              s                    <Plug>Sneak_s
  omap              S                    <Plug>Sneak_S
" }}}
Plug 'lambdalisue/vim-gista'
Plug 'mhinz/vim-signify'
" vim-signify config {{{2
  let g:signify_sign_add               = '+'
  let g:signify_sign_change            = '!'
  let g:signify_sign_delete            = '-'
  let g:signify_sign_delete_first_line = '‾'
  let g:signify_line_highlight         = 0
  let g:signify_update_on_focusgained  = 1
  nnoremap          ,st                 :SignifyToggle<CR>
  nnoremap          ,sh                 :SignifyToggleHighlight<CR>
  nnoremap          ,sd                 :SignifyDiff<CR>
  nnoremap          ,sp                 :SignifyDiffPreview<CR>
" }}}
Plug 'mhinz/vim-sayonara', {'on': 'Sayonara' }
Plug 'mhinz/vim-grepper'
" vim-grepper config {{{2
  nmap              gs                   <plug>(GrepperOperator)
  xmap              gs                   <plug>(GrepperOperator)
  nnoremap          <Leader>g            :Grepper<CR>
  nnoremap          <Leader>*            :Grepper -cword -noprompt<cr>
  let g:grepper                        = {}
  let g:grepper.tools                  = ['rg', 'ag', 'ack', 'grep', 'findstr', 'pt']
  let g:grepper.next_tool              = '<Leader>g'
" }}}
Plug 'romainl/vim-qf'
" vim-qf config {{{2
  let g:qf_mapping_ack_style           = 1
  let g:qf_auto_open_quickfix          = 0
  nmap              <C-q>                <Plug>QfSwitch
  nmap              <C-c>                <Plug>QfCtoggle
  nmap              <C-l>                <Plug>QfLtoggle
  nmap              <Home>               <Plug>QfCprevious
  nmap              <End>                <Plug>QfCnext
  nmap              <C-Home>             <Plug>QfLprevious
  nmap              <C-End>              <Plug>QfLnext
"}}}
Plug 'romainl/vim-qlist'
Plug 'honza/vim-snippets' | Plug 'SirVer/ultisnips'
" ultisnips config {{{2
  let g:UltiSnipsExpandTrigger         = "<Nop>"
" }}}
Plug 'neoclide/coc.nvim', {'do': { -> coc#util#install()}}
" coc.nvim config {{{2
  function! s:check_back_space() abort
    let col = col('.') - 1
    return !col || getline('.')[col - 1]  =~ '\s'
  endfunction
  inoremap <silent><expr> <Tab>
    \ pumvisible() ? "\<C-n>" :
    \ <SID>check_back_space() ? "\<Tab>" :
    \ coc#refresh()
  inoremap <expr> <Tab> pumvisible() ? "\<C-n>" : "\<Tab>"
  inoremap <expr> <S-Tab> pumvisible() ? "\<C-p>" : "\<S-Tab>"
  inoremap <expr> <CR> pumvisible() ? "\<C-y>" : "\<C-g>u\<CR>"

  nmap              ,ca                  :CocAction <CR>
  nmap              ,cc                  :CocConfig <CR>
  nmap              ,cl                  :CocList <C-D>
  nmap              ,clr                 :CocListResume<CR>

  let g:coc_global_extensions = [
    \ 'coc-snippets',
    \ 'coc-vimlsp',
    \ 'coc-lists',
    \ 'coc-pairs',
    \ 'coc-highlight',
    \ 'coc-stylelint',
    \ 'coc-html',
    \ 'coc-css',
    \ 'coc-json'
  \ ]
" }}}
Plug 'wellle/tmux-complete.vim'
Plug 'wellle/targets.vim'
Plug 'scrooloose/nerdcommenter'
" nerdcommenter config {{{2
  let NERDSpaceDelims                  = 1
  let NERDCreateDefaultMappings        = 0
  map               gcc                  <Plug>NERDCommenterToggle
  map               gcu                  <Plug>NERDCommenterUncomment
  map               gcl                  <Plug>NERDCommenterAlignLeft
  map               gcb                  <Plug>NERDCommenterAlignBoth
  map               gca                  <Plug>NERDCommenterAltDelims
  map               gcm                  <Plug>NERDCommenterMinimal
  map               gcn                  <Plug>NERDCommenterNested
  map               gci                  <Plug>NERDCommenterInvert
  map               gcA                  <Plug>NERDCommenterAppend
  map               gc$                  <Plug>NERDCommenterToEOL
  map               gcy                  <Plug>NERDCommenterYank
  map               gcs                  <Plug>NERDCommenterSexy
" }}}
Plug 'simnalamburt/vim-mundo', { 'on': 'MundoToggle' }
" vim-mundo config {{{2
  let g:mundo_verbose_graph            = 0
  let g:mundo_width                    = 28
  let g:mundo_preview_bottom           = 1
  let g:mundo_preview_height           = 14
  nnoremap          ,tu                  :MundoToggle<CR>
" }}}
Plug 'Yggdroot/indentLine'
" indentLine config {{{2
  let g:indentLine_char                = "┊"
  let g:indentLine_fileTypeExclude     = [ 'help', 'man' ]
  nnoremap          ,ti                  :IndentLinesToggle<CR>
" }}}
Plug 'fcpg/vim-spotlightify'
Plug 'markonm/traces.vim'
Plug 'andymass/vim-matchup'
Plug 'brooth/far.vim'
Plug 'qpkorr/vim-renamer'
Plug 'will133/vim-dirdiff'
" vim-dirdiff config {{{2
  let g:DirDiffExcludes                = ".git,.svn,CVS,*.class,*.exe,.*.swp,*.pyc,*.so,*.png,*.jp*g,*.svg,*.tiff"
" }}}
Plug 'vim-voom/VOoM'
" VOoM config {{{2
  let g:voom_tree_width                = 40
  let g:voom_ft_modes                  = {'adoc': 'asciidoc', 'asciidoc': 'asciidoc', 'markdown': 'markdown', 'md': 'markdown', 'rst': 'rest', 'tex': 'latex'}
  nnoremap          ,tv                  :VoomToggle<CR>
" }}}
Plug 'godlygeek/tabular' | Plug 'dhruvasagar/vim-table-mode'
" tabular config {{{2
  nnoremap          <Leader><Tab>        :Tabularize<Space>
  vnoremap          <Leader><Tab>        :Tabularize<Space>
" }}}
" vim-table-mode config {{{2
  let g:table_mode_auto_align          = 1
" }}}
Plug 'jamessan/vim-gnupg'
Plug 'cespare/vim-toml'
Plug 'vim-scripts/SyntaxAttr.vim'
" SyntaxAttr.vim config {{{2
  nnoremap          <F12>                :call SyntaxAttr()<CR>
" }}}
Plug 'vim-scripts/visSum.vim'
Plug 'chrisbra/unicode.vim'
" unicode.vim config {{{2
  let g:Unicode_ShowPreviewWindow      = 1
  nnoremap          <Leader>us           :UnicodeSearch<Space>
  nnoremap          <Leader>ut           :UnicodeTable<CR>
  nnoremap          ga                   :UnicodeName<CR>
" }}}
Plug 'gu-fan/colorv.vim', { 'on': ['ColorV', 'ColorVEdit', 'ColorVPreview', 'ColorVView'] }
" colorv config {{{2
  nnoremap          ,tcp                 :ColorVPreview<CR>
" }}}
Plug 'lifepillar/vim-colortemplate'
" vim-colortemplate config {{{2
  let g:colortemplate_no_stat          =  0
  let g:colortemplate_no_warnings      =  0
" }}}
Plug 'wimstefan/vim-artesanal'
" vim-artesanal config {{{2
  let g:artesanal_italic               =  1
" }}}
Plug 'chriskempson/base16-vim'
Plug 'romainl/Apprentice'

call plug#end()
endif
" " }}}

" General Settings " {{{1
filetype indent plugin on
syntax   on
runtime  ftplugin/man.vim

set backspace=indent,eol,start         " allow backspacing over everything in insert mode
set shiftwidth=2                       " number of spaces used for indention
let &softtabstop = &shiftwidth         " number of spaces that a <Tab> counts for
set shiftround                         " round indent to multiple of 'shiftwidth'
set expandtab                          " use spaces to insert a <Tab>
set smarttab                           " smart tab handling for indenting
set autoindent                         " set autoindenting on
set selection=exclusive                " defines the behaviour of the selection

" backup settings - kudos to https://begriffs.com/posts/2019-07-19-history-use-vim.html
" protect changes between writes
set swapfile
set directory^=~/.cache/vim/swap//
" protect against crash-during-write
set writebackup
" but do not persist backup after successful write
set nobackup
" use rename-and-write-new method whenever safe
set backupcopy=auto
" patch required to honor double slash at end
if has("patch-8.1.0251")
  set backupdir^=~/.cache/vim/backup//
end
" persist the undo tree for each file
set undofile
set undolevels=5000
set undodir^=~/.cache/vim/undo//
set hidden                             " allow buffers to go in background without saving etc.
set autowrite                          " save automatically before critical operations
set autoread                           " automatically reads & loads changes

"set viminfo='50,\"100,:100,%          " read/write a viminfo file with buffer list
set viminfo='50,\"100,:100             " read/write a viminfo file without buffer list
if has ('nvim')
  set viminfo+=n~/.cache/nvim/viminfo " specify where to write the viminfo
else
  set viminfo+=n~/.cache/vim/viminfo " specify where to write the viminfo
endif
set history=100                        " keep 100 lines of command line history

set updatetime=300                     " make things snappier
set number relativenumber              " show line numbers
set cursorcolumn                       " highlights the screen column of the cursor
set cursorline                         " highlights the screen line of the cursor
let &cc='+'.join(range(1,255),',+')    " highlights textwidth boundaries

" virtually wrap lines to fit on the screen
if exists('+linebreak')
  set linebreak showbreak=\ ›››\       " break & visually mark wrapped lines
endif
if has('patch594')
  set breakindent                      " keep indentation of wrapped lines
endif

set ignorecase                         " ignore case when using a search pattern
set smartcase                          " override 'ignorecase' when pattern has upper case characters
set incsearch                          " show matches while typing the query
set hlsearch                           " highlight search results

set list                               " display unprintable characters
set listchars=tab:→\ ,trail:·,eol:«,extends:◀,precedes:▶

set path+=**                          " list of directories which will be searched with find et al
set isfname=@,48-57,/,.,-,_,+,,,#,$,%,~,=,(,),[,],{,}     " allowed characters in file and path names

set wildmenu                           " use a scrollable menu for filename completions
set wildchar=<tab>                     " the char used for 'expansion' on the command line
set wildmode=list:longest,full         " show list of completions and complete as much as possible, then iterate full completions
set wildignore+=*.swp,*.bak,*.pyc,*.cache,*.dll,*.pdb,*.tar.*
set wildignore+=*/.git/**/*,*/.hg/**/*,*/.svn/**/*

set modeline                           " allow the execution of modelines
set showmode                           " shows mode
set showcmd                            " show uncompleted command
set showmatch                          " show matching hyphens
set diffopt+=vertical                  " split vertical
if has("patch-8.1.0360")               " make use of better algorithms if available
  set diffopt+=indent-heuristic,algorithm:histogram
endif
set splitright                         " set vertical splits to split to the right
set splitbelow                         " set horizontal splits to split to the bottom
set previewheight=24                   " set the height of the preview window
set scrolloff=4                        " minimal number of screen lines to keep above and below the cursor

set gdefault                           " always use global substitutions

" Help settings
set keywordprg=:help
nnoremap          <Leader>M            :Man<Space>
augroup help
  autocmd!
  autocmd WinNew * let w:new = 1
  autocmd FileType help,man if exists('w:new') | unlet w:new | wincmd L | vertical resize 84 | endif
augroup END

" Clipboard settings
set clipboard+=unnamed                 " yank+paste with the '*' register

" Mouse settings
set mouse=a                            " enable mouse everywhere
set mousemodel=popup_setpos

" Completion settings
set complete+=kspell                   " currently active spell checking
" ins-completion-menu options
set completeopt+=menuone
set completeopt+=noinsert
set completeopt+=noselect
set completeopt+=preview
set infercase                          " case of the match is adjusted depending on the typed text
if has("autocmd") && exists("+omnifunc") " syntax completion only if a specific plugin does not already exist for that filetype
  autocmd Filetype *
    \  if &omnifunc == "" |
    \    setlocal omnifunc=syntaxcomplete#Complete |
    \  endif
endif

" Fold settings
set foldenable                         " turn on folding
set foldmethod=indent                  " fold on indentation (only use marker if explicitly defined)
set foldlevel=100                      " don't autofold anything (but I can still fold manually)

" Search settings
if executable('rg')
  set grepprg=rg\ --vimgrep\ --no-heading
  set grepformat^=%f:%l:%c:%m
elseif executable('ag')
  " set grepprg=ag\ --nogroup\ --column\ --smart-case\ --nocolor\ --follow
  set grepprg=ag\ --vimgrep
  set grepformat=%f:%l:%c:%m
elseif executable('ack')
  set grepprg=ack\ --nogroup\ --column\ --smart-case\ --nocolor\ --follow\ $*
  set grepformat=%f:%l:%c:%m
endif

" Spell settings
set spelllang=nl,en,de,es
set spellfile=~/.vim/spell/myspell.utf-8.add
if $USER=='root'
  set nospell
else
  set nospell
endif

" Print settings
set printoptions=paper:A4,header:0

" Netrw settings
let g:netrw_winsize                    = 20
let g:netrw_liststyle                  = 3
let g:netrw_preview                    = 0
let g:netrw_alto                       = 0
nnoremap <silent> <Leader>x              :Vexplore<CR>

" " }}}

" Visual " {{{1
if has('nvim')
    set termguicolors
else
  if exists('$TMUX')
    let &t_8f = "\<Esc>[38;2;%lu;%lu;%lum"
    let &t_8b = "\<Esc>[48;2;%lu;%lu;%lum"
  endif
  set termguicolors
endif
if &term =~ "linux"
  color base16-google-dark
else
  if has('gui_running')
    if $USER=='root'
      color apprentice
    else
      if filereadable(expand("~/.vimrc_background"))
        source ~/.vimrc_background
      elseif filereadable(expand("~/.config/colorscheme"))
        source ~/.config/colorscheme
      else
        color PaperColor
      endif
    endif
  else
    if $USER=='root'
      if filereadable(expand("~/.vimrc_background"))
        source ~/.vimrc_background
      elseif filereadable(expand("~/.config/colorscheme"))
        source ~/.config/colorscheme
      else
        color apprentice
      endif
    else
      if filereadable(expand("~/.vimrc_background"))
        source ~/.vimrc_background
      elseif filereadable(expand("~/.config/colorscheme"))
        source ~/.config/colorscheme
      else
        color PaperColor
      endif
    endif
  endif
endif

if has('gui_running')
  set guifont=IBM\ Plex\ Mono\ Medium\ Italic\ 9.0
  set guioptions-=T                    " disable toolbar
  set guioptions-=l                    " disable left scrollbar
  set guioptions-=L
  set guioptions-=r                    " disable right scrollbar
  set guioptions-=R
  set guioptions-=e                    " disables the GUI tab line in favor of the plain text version
endif

" Statusline " {{{2
set laststatus=2                       " always show the statusline
set showtabline=2                      " always show the tabline above

function! MyStatusline()
  let stl  = ''
  if $USER=='root'
    let stl .= '%#Status1# ■ '
  else
    let stl .= ' ■ '
  endif
  if mode() ==? 'i'
    let stl .= '%#Mode1# %f %*'
  elseif mode() ==? 'R'
    let stl .= '%#Mode2# %f %*'
  elseif mode() =~? '[sSvV]'
    let stl .= '%#Mode3# %f %*'
  elseif mode() ==? 'c'
    let stl .= '%#Mode4# %f %*'
  else
    let stl .= '%1* %f %*'
  endif
  if $USER=='root'
    let stl .= '%#Status1# ■ %*'
  else
    let stl .= ' ■ %*'
  endif
  let stl .= '%#Status2#%{&modified ? " ✓ " : ""}%*'
  let stl .= '%#Status1#%{&ro ? " ✗ " : ""}%*'
  if exists('g:loaded_obsession')
    let stl .= '%{ObsessionStatus("⏺", "⏸")}'
  endif
  let stl .= '%= '
  if exists('b:git_dir') && winwidth(0) > 70
    let branch  = fugitive#head(8)
    let stl    .= (branch == 'master') ? '· master' : '· '. branch
    if exists('g:loaded_signify')
      let stl    .= s:sy_stats_wrapper().' · '
    endif
  endif
  let stl .= '%y'
  if winwidth(0) > 70
    if &fileformat != 'unix'
      let stl .= ' %{&encoding}[%{&fileformat}] '
    else
      let stl .= ' %{&encoding} '
    endif
  endif
    let stl .= '%1* %l:%-2c %*'
    let stl .= ' %p%% '
  return stl
  call User_highlights()
endfunction
setlocal statusline=%!MyStatusline()
" " }}}2
" " }}}

" Formatting " {{{1
set comments=b:#,fb:-,fb:*,fb:o,:%,n:>|
set formatoptions=tcrqwnbj
set nrformats+=alpha
nnoremap Q gwap
vnoremap Q gw

" " }}}

" Key mappings & abbreviations " {{{1

" open/source $MYVIMRC
nnoremap          <Leader>ev             :edit    $MYVIMRC<CR>
nnoremap          <Leader>sv             :source  $MYVIMRC<CR>

" editing
" replace the word under cursor globally
nnoremap          <Leader>@              :%s/\<<c-r><c-w>\>//<left>
" write files with sudo
command!                  W               w !sudo tee % > /dev/null

" files
nnoremap <silent> cd                     :<C-u>cd %:h \| pwd<CR>
nnoremap          <Leader>e              :e **/*<C-d>
nnoremap          <Leader>w              :w!<CR>
nnoremap          <Leader>wa             :wa!<CR>
nnoremap          <Leader>q              :q!<CR>
nnoremap          <Leader>qa             :qa!<CR>
nnoremap          <Leader>wqa            :wqa!<CR>

" windows
" move to the split in the direction shown, or create a new split
nnoremap <silent> <C-h>                  :call WinMove('h')<cr>
nnoremap <silent> <C-j>                  :call WinMove('j')<cr>
nnoremap <silent> <C-k>                  :call WinMove('k')<cr>
nnoremap <silent> <C-l>                  :call WinMove('l')<cr>
function! WinMove(key)
  let t:curwin = winnr()
  exec "wincmd ".a:key
  if (t:curwin == winnr())
    if (match(a:key,'[jk]'))
      wincmd v
    else
      wincmd s
    endif
    exec "wincmd ".a:key
  endif
endfunction

" buffers
nnoremap <silent> <Tab>                  :bnext<CR>
nnoremap <silent> <S-Tab>                :bprev<CR>
nnoremap          <Leader><Leader>        <c-^>                     " cycle between last two open buffers
nnoremap          <Leader>bd             :Sayonara<CR>

" tabs
nnoremap          <Leader>td             :tabclose<CR>

" terminals
nnoremap          <Leader>t              :terminal<CR>
nnoremap          <Leader>vt             :vertical terminal<CR>

" signatures
nnoremap          <Leader>sa 1G:s#\(Stefan Wimmer\) <.*>#\1 <stefan@tangoartisan.com>#<CR>
  \ G?--<CR>
  \ jVGd :r ~/.mutt/short-signature-artisan<CR>
  \ /^To:<CR>
nnoremap          <Leader>sg 1G:s#\(Stefan Wimmer\) <.*>#\1 <wimstefan@gmail.com>#<CR>
  \ G?--<CR>
  \ jVGd :r ~/.mutt/short-signature-gmail<CR>
  \ /^To:<CR>
nnoremap          <Leader>st G?--<CR>jVGd :r ~/.mutt/short-signature-tango<CR>
nnoremap          <Leader>ss G?--<CR>jVGd :r ~/.mutt/short-signature<CR>
nnoremap          <Leader>sl G?--<CR>jVGd :r ~/.mutt/signature<CR>

" some ideas stolen from tpope/vim-unimpaired
function! s:statusbump() abort
  let &l:readonly = &l:readonly
  return ''
endfunction

function! s:toggle(op) abort
  call s:statusbump()
  return eval('&'.a:op) ? 'no'.a:op : a:op
endfunction

function! s:option_map(letter, option, mode) abort
  exe 'nnoremap [o'.a:letter ':'.a:mode.' '.a:option.'<C-r>=<SID>statusbump()<CR><CR>'
  exe 'nnoremap ]o'.a:letter ':'.a:mode.' no'.a:option.'<C-r>=<SID>statusbump()<CR><CR>'
  exe 'nnoremap co'.a:letter ':'.a:mode.' <C-r>=<SID>toggle("'.a:option.'")<CR><CR>'
endfunction

nnoremap [ob :set background=light<CR>
nnoremap ]ob :set background=dark<CR>
nnoremap cob :set background=<C-r>=&background == 'dark' ? 'light' : 'dark'<CR><CR>
call s:option_map('c', 'cursorline', 'setlocal')
call s:option_map('u', 'cursorcolumn', 'setlocal')
nnoremap [od :diffthis<CR>
nnoremap ]od :diffoff<CR>
nnoremap cod :<C-r>=&diff ? 'diffoff' : 'diffthis'<CR><CR>
call s:option_map('h', 'hlsearch', 'set')
call s:option_map('i', 'ignorecase', 'set')
call s:option_map('l', 'list', 'setlocal')
call s:option_map('n', 'number', 'setlocal')
call s:option_map('r', 'relativenumber', 'setlocal')
call s:option_map('s', 'spell', 'setlocal')
nnoremap [ox :set cursorline cursorcolumn<CR>
nnoremap ]ox :set nocursorline nocursorcolumn<CR>
nnoremap cox :set <C-r>=&cursorline && &cursorcolumn ? 'nocursorline nocursorcolumn' : 'cursorline cursorcolumn'<CR><CR>
nnoremap corn :set <C-r>=&number && &relativenumber ? 'nonumber norelativenumber' : 'number relativenumber'<CR><CR>
nnoremap com :<C-u>set colorcolumn=<C-R>=&colorcolumn == '+'.join(range(1,255),',+') ? '' : '+'.join(range(1,255),',+')<CR><CR><CR>
nnoremap [cl :highlight CursorLine cterm=bold,italic gui=bold,italic<CR>
nnoremap ]cl :highlight CursorLine cterm=none gui=none<CR>
nmap [<Space> O<Esc>j
nmap ]<Space> o<Esc>k

" various
set pastetoggle=<F3>

" Abbreviations
source ~/.vim/abbreviations.vim
" " }}}

" Auto commands " {{{1
augroup vimrc
  autocmd!
  " Automatically chmod +x Shell and Perl scripts
  autocmd BufWritePost {*.sh,*.pl,*.py} silent !chmod +x %

  " Commentstrings
  autocmd FileType xdefaults setlocal commentstring=!\%s
  autocmd FileType mail setlocal commentstring=>\%s

  " Typical mutt thing ... replace > > with >>
  autocmd BufRead /tmp/mutt* silent! %s/^\([>|]\s\?\)\+/\=substitute(submatch(0), '\s', '', 'g').' '
  autocmd BufRead /tmp/mutt* set nonumber nohls nolist filetype=mail formatoptions=tcroqwln21
  autocmd BufRead /tmp/mutt* setlocal spell

  " Syntax for tmux
  autocmd BufNewFile,BufRead *tmux*conf* set filetype=tmux

  " Syntax for conkyrc
  autocmd BufNewFile,BufRead *conkyrc* set filetype=conkyrc

  " Syntax for htp files
  autocmd BufNewFile,BufRead {*.htp,*.htt} set filetype=xhtml

  " Syntax for xmp files
  autocmd BufNewFile,BufRead {*.xmp} set filetype=xml

  " Syntax for fvwm files
  autocmd BufNewFile,BufRead */.fvwm*/* set filetype=fvwm syntax=fvwm

  " Syntax for Xorg log files
  autocmd BufNewFile,BufRead *Xorg*log* set filetype=msmessages

  " Syntax for rofi themes
  autocmd BufNewFile,BufRead {*.rasi} set filetype=css

  " Change fileformat on playlist files (created by moc)
  autocmd BufNewFile,BufRead *.m3u set encoding=utf-8 fileencoding=utf-8 ff=unix

  " run xrdb whenever Xdefaults or Xresources are updated
  autocmd BufWritePost X{resources,defaults} silent !xrdb %

  " Encoding for cddb files
  autocmd BufNewFile,BufRead *cddb* set encoding=utf-8 fileencoding=utf-8 ff=unix

  " Enable spelling for text files
  autocmd BuFNewFile,BufRead {*.txt,*.md,*.asciidoc,*.rst} if &filetype !~ 'man\|help\|*doc' | setlocal spell | endif

  " Disable numbers & spell inside manpages
  autocmd FileType {man,help,*doc} setlocal nonumber norelativenumber nospell nolist nocursorcolumn

  " When editing a file, always jump to the last known cursor position.
  autocmd BufReadPost *
    \ if line("'\"") > 0 && line("'\"") <= line("$") |
    \   exe "normal g`\"" |
    \ endif

  " Reload user defined highlights after changing colorschemes
  autocmd VimEnter,ColorScheme * call User_highlights()

  " Reload statusline after changing windows/buffer/tab
  autocmd BufEnter * setlocal statusline=%!MyStatusline()

  " Resize windows automagically
  autocmd VimResized * :wincmd =

  " Automatically reload vimrc when it's saved
  autocmd BufWritePost vimrc,.vimrc nested source $MYVIMRC

augroup END
" " }}}

" Functions " {{{1
function! User_highlights() abort
  " https://gist.github.com/ahmedelgabri/b9127dfe36ba86f4496c8c28eb65ef2b
  let bgcolorgui=synIDattr(synIDtrans(hlID("Statusline")), "bg", "gui")
  let bgcolorterm=synIDattr(synIDtrans(hlID("Statusline")), "bg", "cterm")

  highlight User1 cterm=reverse gui=reverse

  exe 'highlight Status1 ctermfg=1 guifg=#e05a72'
  exe 'highlight Status2 ctermfg=2 guifg=#59b387'
  exe 'highlight Status3 ctermfg=3 guifg=#ffcc66'
  exe 'highlight Status4 ctermfg=4 guifg=#5f87af'

  exe 'highlight Mode1 ctermfg=0 ctermbg=2 guifg=#2e3440 guibg=#59b387'
  exe 'highlight Mode2 ctermfg=0 ctermbg=4 guifg=#2e3440 guibg=#5f87af'
  exe 'highlight Mode3 ctermfg=0 ctermbg=3 guifg=#2e3440 guibg=#ffcc66'
  exe 'highlight Mode4 ctermfg=0 ctermbg=1 guifg=#2e3440 guibg=#e05a72'
endfunction

function! s:sy_stats_wrapper()
  let symbols = ['+', '-', '~']
  let [added, modified, removed] = sy#repo#get_stats()
  let stats = [added, removed, modified]  " reorder
  let hunkline = ''

  for i in range(3)
    if stats[i] > 0
      let hunkline .= printf('%s%s ', symbols[i], stats[i])
    endif
  endfor

  if !empty(hunkline)
    let hunkline = printf(' %s', hunkline[:-2])
  endif

  return hunkline
endfunction

" " }}}

finish
Vim is ignoring *all* text after finish.
