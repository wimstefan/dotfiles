" Just a few settings
" Check settings with ":verbose set <setting>?"
" vim: fdm=marker fdl=0 tw=200

" reset to vim-defaults
if &compatible          " only if not set before:
  set nocompatible      " use vim-defaults instead of vi-defaults (easier, more user friendly)
endif
" utf-8 settings
scriptencoding utf-8
set encoding=utf-8
set termencoding=utf-8

" Plugins " {{{1
if empty(glob('~/.vim/autoload/plug.vim'))
  silent !curl -fLo ~/.vim/autoload/plug.vim --create-dirs
    \ https://raw.githubusercontent.com/junegunn/vim-plug/master/plug.vim
  autocmd VimEnter * PlugInstall
endif
nnoremap ,pc :PlugClean<CR>
nnoremap ,pi :PlugInstall<CR>
nnoremap ,ps :PlugStatus<CR>
nnoremap ,pu :PlugUpdate<CR>
let g:plug_shallow = 0

silent! if  plug#begin('~/.vim/plugged')
Plug 'junegunn/fzf', { 'dir': '~/.fzf', 'do': 'yes \| ./install' }
" fzf config {{{2
  set rtp+=~/.fzf
" }}}
Plug 'junegunn/fzf.vim'
" fzf.vim config {{{2
  nnoremap <Leader>p :Files<CR>
  nnoremap <Leader>a :Ag 
  nnoremap        ,w :Ag <C-r><C-w><CR>
  nnoremap <Leader>b :Buffers<CR>
  nnoremap <Leader>c :Colors<CR>
  nnoremap <Leader>l :Locate 
  nnoremap <Leader>m :History<CR>
  nnoremap <Leader>t :BTags<CR>
  imap <c-x><c-f> <plug>(fzf-complete-file-ag)
  imap <c-x><c-l> <plug>(fzf-complete-line)
" }}}
Plug 'junegunn/vim-peekaboo'
Plug 'junegunn/vim-easy-align'
" vim-easy-align config {{{2
  vnoremap <silent> <Enter> :EasyAlign<cr>
  nmap ea <Plug>(EasyAlign)
  vmap . <Plug>(EasyAlignRepeat)
" }}}
Plug 'tpope/vim-abolish'
Plug 'tpope/vim-characterize'
Plug 'tpope/vim-commentary'
Plug 'tpope/vim-dispatch'
Plug 'tpope/vim-eunuch'
Plug 'tpope/vim-repeat'
Plug 'tpope/vim-surround'
Plug 'tpope/vim-unimpaired'
Plug 'tpope/vim-vinegar'
Plug 'tpope/vim-fugitive' | Plug 'gregsexton/gitv'
" vim-fugitive config {{{2
  let g:Gitv_OpenHorizontal = 'auto'
  nnoremap <Leader>gt :!tig<CR>:redraw!<CR>
  nnoremap <silent> <leader>gv :Gitv --all<CR>
  nnoremap <silent> <leader>gV :Gitv! --all<CR>
  vnoremap <silent> <leader>gV :Gitv! --all<CR>
" }}}
Plug 'mhinz/vim-signify'
" vim-signify config {{{2
  let g:signify_sign_add               = '+'
  let g:signify_sign_change            = '!'
  let g:signify_sign_delete            = '-'
  let g:signify_sign_delete_first_line = '‾'
  let g:signify_line_highlight = 1
  nnoremap ,tsg :SignifyToggle<CR>
" }}}
Plug 'mhinz/vim-startify'
" vim-startify config {{{2
  let g:startify_session_dir = $HOME.'/.cache/vim/session'
  let g:startify_custom_header = []
  let g:startify_skiplist = [
    \ 'COMMIT_EDITMSG',
    \ ]
  let g:startify_bookmarks = [
    \ '~/.dotfiles/vim/vimrc',
    \ '~/.dotfiles/zsh/zshrc',
    \ '~/.dotfiles/config/awesome/rc.lua'
    \ ]
" }}}
Plug 'mhinz/vim-sayonara'
Plug 'wellle/targets.vim'
Plug 'wellle/tmux-complete.vim'
Plug 'mbbill/undotree', { 'on': 'UndotreeToggle' }
" undotree config {{{2
  let g:undotree_WindowLayout = 2
  nnoremap ,tu :UndotreeToggle<CR>
" }}}
Plug 'ajh17/VimCompletesMe'
Plug 'Shougo/vimproc.vim', { 'do': 'make' } | Plug 'Shougo/vimshell.vim'
" vimshell config {{{2
  let g:vimshell_data_directory = $HOME.'/.cache/vim/vimshell'
" }}}
Plug 'qpkorr/vim-renamer'
Plug 'will133/vim-dirdiff'
" vim-dirdiff config {{{2
  let g:DirDiffExcludes = ".git,.svn,CVS,*.class,*.exe,.*.swp,*.pyc,*.so"
" }}}
Plug 'VOoM'
" VOoM config {{{2
  let g:voom_tree_width = 40
  nnoremap ,tv :VoomToggle<CR>
" }}}
Plug 'rkitover/vimpager'
Plug 'powerman/vim-plugin-viewdoc'
" vim-plugin-viewdoc config {{{2
  let g:viewdoc_open='rightbelow 79vnew'
  let g:viewdoc_openempty = 0
  let g:viewdoc_dontswitch = 0
  nnoremap <Leader>h :ViewDocHelp 
" }}}
Plug 'godlygeek/tabular' | Plug 'dhruvasagar/vim-table-mode'
" vim-table-mode config {{{2
  let g:table_mode_corner = '+'
  let g:table_mode_fillchar = '-'
  let g:table_mode_align_char = ':'
" }}}
Plug 'dahu/vimple' | Plug 'dahu/Asif' | Plug 'SyntaxRange' | Plug 'dahu/vim-asciidoc'
" vim-asciidoc config {{{2
  let g:asciidoc_title_style = "atx"
  let g:asciidoc_title_style_atx = "symmetric"
" }}}
Plug 'gabrielelana/vim-markdown'
Plug 'farseer90718/vim-taskwarrior', { 'on': 'TW' }
Plug 'jamessan/vim-gnupg'
Plug 'mattn/emmet-vim', { 'for': ['html', 'xhtml', 'css', 'xml', 'xls', 'markdown'] }
Plug 'mattn/webapi-vim' | Plug 'mattn/gist-vim', { 'on': 'Gist' } | Plug 'mattn/googletasks-vim'
" webapi-vim config {{{2
  let g:gist_post_private = 1
  let g:gist_clip_command = 'xclip -selection clipboard'
" }}}
Plug 'achiang/muttrc'
Plug 'SyntaxAttr.vim'
Plug 'visSum.vim'
Plug 'gorodinskiy/vim-coloresque'
Plug '$HOME/.vim/plugged/my-base16-vim'
" base16-vim config {{{2
  let base16colorspace=256
  let g:base16_shell_path="$HOME/.config/base16-shell"
" }}}
Plug 'wimstefan/Lightning'
Plug 'romainl/Apprentice'
Plug 'AlessandroYorba/Sierra'
" Sierra config {{{2
  let g:sierra_Pitch = 1
" }}}
Plug 'NLKNguyen/papercolor-theme'
Plug 'joshdick/onedark.vim'
Plug 'reedes/vim-colors-pencil'

call plug#end()
endif
" " }}}

" General Settings " {{{1
set textwidth=80                       " define an acceptable standard textwidth
set backspace=2                        " allow backspacing over everything in insert mode
set shiftwidth=2                       " number of spaces used for indention
set tabstop=2                          " tabstop length
set softtabstop=2                      " number of spaces that a <Tab> counts for
set expandtab                          " use spaces to insert a <Tab>
set smarttab                           " smart tab handling for indenting
set autoindent                         " set autoindenting on
set hidden                             " allow buffers to go in background without saving etc.
set autowrite                          " save automatically before critical operations
set autoread                           " automatically reads & loads changes
"set autochdir                          " change directory to the current buffer when opening files
set nobackup                           " keep a backup file
"set fileformat=unix                    " always on a linux box (!) :-) - 2012-12-06 doesn't work with vimpager :-/
"set viminfo='50,\"100,:100,%          " read/write a viminfo file with buffer list
set viminfo='50,\"100,:100             " read/write a viminfo file without buffer list
if has ('nvim')
  let $NVIM_TUI_ENABLE_TRUE_COLOR=1
  set viminfo+=n$HOME/.cache/nvim/viminfo " specify where to write the viminfo
else
  set viminfo+=n$HOME/.cache/vim/viminfo " specify where to write the viminfo
endif
set history=100                        " keep 100 lines of command line history
set number                             " show line numbers
set cursorcolumn                       " highlights the screen column of the cursor
set cursorline                         " highlights the screen line of the cursor
let &cc='+'.join(range(1,255),',+')    " highlights textwidth boundaries
set gdefault                           " always use global substitutions
set digraph                            " enter characters that normally can't be entered by keyboard
set ignorecase                         " ignore case when using a search pattern
set smartcase                          " override 'ignorecase' when pattern has upper case characters
set incsearch                          " show matches while typing the query
set hlsearch                           " highlight search results
set wildchar=<tab>                     " the char used for 'expansion' on the command line
set wildmode=list:longest,full         " show list of completions and complete as much as possible, then iterate full completions
set wildmenu                           " use a scrollable menu for filename completions
set list                               " display unprintable characters
"set listchars=tab:→\ ,trail:·,eol:«    " tabstops, trailing whitespace, and end-of-lines
set listchars=tab:→\ ,trail:·,eol:«,extends:↷,precedes:↶
set isfname=@,48-57,/,.,-,_,+,,,#,$,%,~,=,(,),[,],{,}     " allowed characters in file and path names
set modeline                           " allow the execution of modelines which is disabled in /etc/vim/vimrc
set showmode                           " shows mode
set showcmd                            " show uncompleted command
set showmatch                          " show matching hyphens
set diffopt=vertical,iwhite,filler     " split vertical, ignore whitespace & use filler
set splitright                         " Set vertical splits to split to the right
set clipboard+=unnamed                 " yank+paste without the "* register
set splitbelow                         " Set horizontal splits to split to the bottom

" Use persistent undo
if has('persistent_undo')
    set undodir=$HOME/.cache/vim/undo
    set undolevels=5000
    set undofile
endif

" Netrw settings
let g:netrw_winsize        = 20
let g:netrw_liststyle      =  3
let g:netrw_preview        =  1
let g:netrw_special_syntax =  1
nnoremap <silent> <Leader>x :Lexplore<CR>

" Search settings
if executable('ag')
  " set grepprg=ag\ --nogroup\ --column\ --smart-case\ --nocolor\ --follow
  set grepprg=ag\ --vimgrep
  set grepformat=%f:%l:%c:%m
elseif executable('ack')
  set grepprg=ack\ --nogroup\ --column\ --smart-case\ --nocolor\ --follow\ $*
  set grepformat=%f:%l:%c:%m
endif

" Spell settings
set spelllang=nl,en,de,es
set spellfile=~/.vim/spell/myspell.utf-8.add
set spellsuggest=fast
if $USER=='root'
  set nospell
else
  set nospell
endif

" Set print options
set printoptions=paper:A4,duplex:long,collate:y,syntax:n
set printexpr=PrettyPrint(v:fname_in)
function! PrettyPrint(fname)
    call system('a2ps -B -2 -s2 -PHL-2250DN '.a:fname)
    return v:shell_error
endfunc
" " }}}

" Visual " {{{1
if &term =~ "linux"
  color torte
else
  if has('gui_running')
    if $USER=='root'
      color onedark
    else
      set background=dark
      source $HOME/.config/colorscheme
    endif
  else
    if $USER=='root'
      set background=dark
      source $HOME/.config/colorscheme
    else
      set background=dark
      source $HOME/.config/colorscheme
    endif
  endif
endif

if exists('vimpager')
  set colorcolumn=0
  set nolist
endif

set guifont=Hurmit\ 9
set guioptions-=T                      " disable toolbar

filetype indent plugin on | syn on     " enable filetype, plugin and syntax support

set foldenable                         " turn on folding
set foldmethod=indent                  " fold on indentation (only use marker if explicitly defined)
set foldlevel=100                      " don't autofold anything (but I can still fold manually)

set mouse=a                            " enable mouse in console
set mousemodel=popup_setpos
if !has('nvim')
  set ttymouse=xterm2
endif

" Statusline " {{{2
set laststatus=2                       " always show the statusline above
set guioptions-=e                      " disables the GUI tab line in favor of the plain text version

function! s:user_highlights()
  exec 'hi CursorLine cterm=underline gui=underline'
  exec 'hi User1 cterm=reverse gui=reverse'
  exec 'hi User2 ctermfg=1 ctermbg=' . synIDattr(hlID('StatusLine'), 'bg', 'cterm') . ' guifg=#ff0000 guibg=' . synIDattr(hlID('StatusLine'), 'bg', 'gui')
  exec 'hi User3 ctermfg=2 ctermbg=' . synIDattr(hlID('StatusLine'), 'bg', 'cterm') . ' guifg=#008800 guibg=' . synIDattr(hlID('StatusLine'), 'bg', 'gui')
  exec 'hi User4 ctermfg=3 ctermbg=' . synIDattr(hlID('StatusLine'), 'bg', 'cterm') . ' guifg=#ffff00 guibg=' . synIDattr(hlID('StatusLine'), 'bg', 'gui')
  exec 'hi User5 ctermfg=4 ctermbg=' . synIDattr(hlID('StatusLine'), 'bg', 'cterm') . ' guifg=#0000ff guibg=' . synIDattr(hlID('StatusLine'), 'bg', 'gui')
endfunction
call s:user_highlights()

function! MyStatusline()
  let stl  = ''
  if $USER=='root'
    let stl .= '%2*░▒▓'
  else
    let stl .= '░▒▓'
  endif
  let stl .= '%1* %F%h%w%q '
  if exists('b:git_dir')
    let branch  = fugitive#head(8)
    let stl    .= (branch == 'master') ? ' ⑆ master' : ' ⑆ '. branch
    let stl    .= s:sy_stats_wrapper().' '
  endif
  let stl .= '%3*%{&modified ? " ✓ " : ""}%*'
  let stl .= '%2*%{&ro ? " ✗ " : ""}%*'
  if $USER=='root'
    let stl .= '%2*▓▒░%*'
  else
    let stl .= '▓▒░%*'
  endif
  let stl .= '%= '
        \ .  '%w %y [%{&encoding}:%{&fileformat}]'
        \ .  ' (%l/%L, %-2c) '
        \ .  ' %p%% '
  return stl
endfunction
set statusline=%!MyStatusline()
" " }}}2
" Tabline " {{{2
set showtabline=2                      " always show tabline, even if there is just one tab, avoid
                                       " redraw problems when Window is displayed in fullscreen mode
function! MyTabLine()
  let s = ''
  let t = tabpagenr()
  let i = 1
  while i <= tabpagenr('$')
    let buflist = tabpagebuflist(i)
    let winnr = tabpagewinnr(i)
    let s .= '%' . i . 'T'
    let s .= (i == t ? '%1*' : '%2*')

    " let s .= (i == t ? '%#TabLineSel#' : '%#TabLine#')
    " let s .= ' '
    let s .= (i == t ? '%#TabNumSel#' : '%#TabNum#')
    let s .= ' ' . i . ' '
    let s .= (i == t ? '%#TabLineSel#' : '%#TabLine#')

    let bufnr = buflist[winnr - 1]
    let file = bufname(bufnr)
    let buftype = getbufvar(bufnr, '&buftype')

    if buftype == 'help'
      let file = 'help:' . fnamemodify(file, ':t:r')

    elseif buftype == 'quickfix'
      let file = 'quickfix'

    elseif buftype == 'nofile'
      if file =~ '\/.'
        let file = substitute(file, '.*\/\ze.', '', '')
      endif

    else
      let file = pathshorten(fnamemodify(file, ':p:~:.'))
      if getbufvar(bufnr, '&modified')
        let file = file . ' ±'
      endif

    endif

    if file == ''
      let file = '[No Name]'
    endif

    let s .= ' ' . file

    let nwins = tabpagewinnr(i, '$')
    if nwins > 1
      let modified = ''
      for b in buflist
        if getbufvar(b, '&modified') && b != bufnr
          let modified = '*'
          break
        endif
      endfor
      let hl = (i == t ? '%#WinNumSel#' : '%#WinNum#')
      let nohl = (i == t ? '%#TabLineSel#' : '%#TabLine#')
      let s .= ' ' . modified . '(' . hl . winnr . nohl . '/' . nwins . ')'
    endif

    if i < tabpagenr('$')
      let s .= ' %#TabLine#|'
    else
      let s .= ' '
    endif

    let i = i + 1

  endwhile

  let s .= '%T%#TabLineFill#%='
  let s .= (tabpagenr('$') > 1 ? '%#TabNum#%999XX%*' : '%#TabNum#X%*')
  return s

endfunction

set tabline=%!MyTabLine()
" " }}}2
" " }}}

" Formatting " {{{1
" Format texts. Really cool.
set comments=b:#,fb:-,fb:*,fb:o,:%,n:>|
set formatoptions=tcrqwnbj
nnoremap Q gwap
vnoremap Q gw

" " }}}

" Key bindings & abbreviations " {{{1

" open/source $MYVIMRC
nnoremap <Leader>ev :edit    $MYVIMRC<CR>
nnoremap <Leader>sv :source  $MYVIMRC<CR>

" :w! is always bad to type ...
nnoremap <Leader>w :w!<CR>

" switch buffers
" Note: :b foo  will also select some-foo-text.txt file if it was opened :)
"noremap <Leader>b :ls<CR>:b<Space>
nnoremap <Leader>bn :bnext<CR>
nnoremap <Leader>bp :bprev<CR>
nnoremap <Leader>bd :Sayonara<CR>

" switch colorscheme for console
nnoremap <C-d> :set background=dark<CR>:colorscheme PaperColor<CR>

set pastetoggle=<F3>
nnoremap <F12> :call SyntaxAttr()<CR>

" Replace signatures
nnoremap <Leader>sa 1G:s#\(Stefan Wimmer\) <.*>#\1 <stefan@tangoartisan.com>#<CR>
  \ G?--<CR>
  \ jVGd :r ~/.mutt/short-signature-artisan<CR>
  \ /^To:<CR>
nnoremap <Leader>st G?--<CR>jVGd :r ~/.mutt/short-signature-tango<CR>
nnoremap <Leader>ss G?--<CR>jVGd :r ~/.mutt/short-signature<CR>
nnoremap <Leader>sl G?--<CR>jVGd :r ~/.mutt/signature<CR>

" underline mappings
map h1 yypVr=
map h2 yypVr-

" Abbreviations
source $HOME/.vim/abbreviations.vim
" " }}}

" Auto commands " {{{1
" Automatically chmod +x Shell and Perl scripts
autocmd BufWritePost {*.sh,*.pl,*.py} silent !chmod +x %

" Differing commentstrings
autocmd FileType xdefaults set commentstring=!\%s
autocmd FileType mail set commentstring=>\%s
autocmd FileType gentoo-package* set commentstring=#\%s
autocmd FileType gentoo-conf* set commentstring=#\%s
autocmd FileType sshdconfig* set commentstring=#\%s
autocmd FileType cfg* set commentstring=#\%s
autocmd FileType tmux* set commentstring=#\%s

" Typical mutt thing ... replace > > with >>
autocmd BufRead /tmp/mutt* silent! %s/^\([>|]\s\?\)\+/\=substitute(submatch(0), '\s', '', 'g').' '
autocmd BufRead /tmp/mutt* set nonumber nohls nolist filetype=mail formatoptions=tcroqln21
autocmd BufRead /tmp/mutt* setlocal spell

" Syntax for tmux
au BufNewFile,BufRead *tmux*conf* set filetype=tmux

" Syntax for conkyrc
au BufNewFile,BufRead *conkyrc* set filetype=conkyrc

" Syntax for htp files
au BufNewFile,BufRead {*.htp,*.htt} set filetype=xhtml

" Syntax for xmp files
au BufNewFile,BufRead {*.xmp} set filetype=xml

" Syntax for fvwm files
au BufNewFile,BufRead */.fvwm*/* set filetype=fvwm syntax=fvwm

" Syntax for Xorg log files
au BufNewFile,BufRead *Xorg*log* set filetype=msmessages

" Change fileformat on playlist files (created by moc)
au BufNewFile,BufRead *.m3u set encoding=utf-8 fileencoding=utf-8 ff=unix

" Encoding for cddb files
au BufNewFile,BufRead *cddb* set encoding=utf-8 fileencoding=utf-8 ff=unix

" Disable numbers & spell inside manpages
autocmd FileType {man,help,perldoc,pydoc}  set nonumber nospell nolist nocursorcolumn

" When editing a file, always jump to the last known cursor position.
autocmd BufReadPost *
  \ if line("'\"") > 0 && line("'\"") <= line("$") |
  \       exe "normal g`\"" |
  \ endif

" Reload user defined highlights after changing colorschemes
autocmd ColorScheme * call s:user_highlights()

" Automatically reload vimrc when it's saved
augroup AutoReloadVimRC
  autocmd!
  autocmd BufWritePost $MYVIMRC source $MYVIMRC
augroup END

" Transparent editing of archived files.
augroup gzip
  " Remove all gzip autocommands
  au!
  " Enable editing of gzipped files
  " set binary mode before reading the file
  autocmd BufReadPre,FileReadPre *.gz,*.bz2 set bin
  autocmd BufReadPost,FileReadPost *.gz call GZIP_read("gunzip")
  autocmd BufReadPost,FileReadPost *.bz2 call GZIP_read("bunzip2")
  autocmd BufWritePost,FileWritePost *.gz call GZIP_write("gzip")
  autocmd BufWritePost,FileWritePost *.bz2 call GZIP_write("bzip2")
  autocmd FileAppendPre   *.gz call GZIP_appre("gunzip")
  autocmd FileAppendPre   *.bz2 call GZIP_appre("bunzip2")
  autocmd FileAppendPost  *.gz call GZIP_write("gzip")
  autocmd FileAppendPost  *.bz2 call GZIP_write("bzip2")
  " After reading compressed file: Uncompress text in buffer with "cmd"
  fun! GZIP_read(cmd)
    let ch_save = &ch
    set ch=2
    execute "'[,']!" . a:cmd
    set nobin
    let &ch = ch_save
    execute ":doautocmd BufReadPost " . expand("%:r")
  endfun
  " After writing compressed file: Compress written file with "cmd"
  fun! GZIP_write(cmd)
    if rename(expand("<afile>"), expand("<afile>:r")) == 0
      execute "!" . a:cmd . " <afile>:r"
    endif
  endfun
  " Before appending to compressed file: Uncompress file with "cmd"
  fun! GZIP_appre(cmd)
    execute "!" . a:cmd . " <afile>"
    call rename(expand("<afile>:r"), expand("<afile>"))
  endfun
augroup END

" " }}}

" Runtime & commands " {{{1
runtime macros/matchit.vim    " very nice extension to %-matching
" " }}}

" Functions " {{{1
function! s:sy_stats_wrapper()
  let symbols = ['+', '-', '~']
  let [added, modified, removed] = sy#repo#get_stats()
  let stats = [added, removed, modified]  " reorder
  let hunkline = ''

  for i in range(3)
    if stats[i] > 0
      let hunkline .= printf('%s%s ', symbols[i], stats[i])
    endif
  endfor

  if !empty(hunkline)
    let hunkline = printf(' [%s]', hunkline[:-2])
  endif

  return hunkline
endfunction

" " }}}

finish
Vim is ignoring *all* text after finish.
